> In modern Java, synchronized is highly optimized and should be the default choice for
most concurrency needs. ReentrantLock is only justified when advanced features like tryLock,
fairness, or timed waits are required. For typical rate limiters and in-memory state,
synchronized is simpler, safer, and performant.


> Marking of Window class as static in FixedWindowStrategy

1. Memory Efficiency

When an inner class is non-static, it holds an implicit reference to its enclosing class instance
This creates a hidden memory overhead as each Window object would maintain a reference to its FixedWindowStrategy instance
By making it static, we eliminate this unnecessary reference

2. Prevents Memory Leaks

Without static, even if you want to garbage collect a Window instance, it can't be collected until its outer FixedWindowStrategy instance is also eligible for garbage collection
This could lead to memory leaks, especially in a rate limiter that creates many window instances over time

> Also, marking the Window class as static doesn't affect the isolation between different window instances. Each Window object gets its own copy of the instance variables and thus value wont be affected.

// Each API gets its own Window instance with isolated counters
Map<String, Window> apiVsWindowMap = new ConcurrentHashMap<>();

// API-1 gets its own Window
apiVsWindowMap.put("api1", new Window(currentTime)); // Has its own requestCount
// API-2 gets a different Window
apiVsWindowMap.put("api2", new Window(currentTime)); // Has its own requestCount


> Diff strategies :

Fixed Window Rate Limiter

Divides time into fixed intervals (e.g., 1 minute) and allows a given maximum number of requests per window.
Simple and efficient but can allow traffic spikes at window boundaries.
Best suited for basic limits where precision is not critical.

Sliding Window Rate Limiter

Tracks request timestamps over a rolling time window to smooth traffic evenly.
Prevents burst spikes seen in fixed windows but requires more memory and computation.
Ideal when fairness and smooth request distribution are important.

Token Bucket Rate Limiter

Tokens are added to a bucket at a fixed rate, and each request consumes a token.
Allows short bursts while enforcing a long-term average rate.
Commonly used in APIs and network systems for flexible and efficient rate limiting.